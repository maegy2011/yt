import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'

// Use dynamic import for youtubei to avoid module resolution issues
let Client: any
let youtubei: any

const initializeYoutubei = async () => {
  try {
    const youtubeiModule = await import('youtubei')
    youtubei = youtubeiModule.default || youtubeiModule
    Client = youtubei.Client || youtubeiModule.Client
    // Console statement removed
  } catch (error) {
    // Console statement removed
  }
}

// Initialize immediately
initializeYoutubei().catch(console.error)

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const channelId = searchParams.get('channelId')
    const includeComparison = searchParams.get('includeComparison') === 'true'
    const timeframe = searchParams.get('timeframe') || 'all' // all, month, week

    // Console statement removed

    if (channelId) {
      // Get stats for specific channel
      return await getSingleChannelStats(channelId, includeComparison, timeframe)
    } else {
      // Get overall channel statistics
      return await getAllChannelsStats(includeComparison, timeframe)
    }
  } catch (error) {
    // Console statement removed
    return NextResponse.json({ 
      error: 'Failed to fetch channel statistics',
      details: process.env.NODE_ENV === 'development' && error instanceof Error ? error.message : undefined
    }, { status: 500 })
  }
}

async function getSingleChannelStats(channelId: string, includeComparison: boolean, timeframe: string) {
  try {
    // Get channel from favorites
    const favoriteChannel = await db.favoriteChannel.findUnique({
      where: { channelId }
    })

    if (!favoriteChannel) {
      return NextResponse.json({ error: 'Channel not found in favorites' }, { status: 404 })
    }

    // Get channel data from YouTube API
    if (!Client) {
      return NextResponse.json({ error: 'YouTube client not initialized' }, { status: 500 })
    }
    const youtube = new Client()
    const channelData = await youtube.getChannel(channelId)

    if (!channelData) {
      return NextResponse.json({ error: 'Channel data not available' }, { status: 404 })
    }

    // Calculate statistics
    const stats: any = {
      channelId: channelId,
      name: channelData.name,
      thumbnail: (channelData as any).thumbnail?.url || (channelData as any).thumbnail || (channelData as any).thumbnails?.[0]?.url,
      subscriberCount: channelData.subscriberCount || 0,
      videoCount: channelData.videoCount || 0,
      viewCount: (channelData as any).viewCount || 0,
      addedAt: favoriteChannel.addedAt,
      daysInFavorites: Math.floor((Date.now() - new Date(favoriteChannel.addedAt).getTime()) / (1000 * 60 * 60 * 24)),
      stats: {
        subscribers: channelData.subscriberCount || 0,
        totalVideos: channelData.videoCount || 0,
        totalViews: (channelData as any).viewCount || 0,
        avgViewsPerVideo: (channelData.videoCount && (channelData as any).viewCount) ? 
          Math.round(Number((channelData as any).viewCount) / Number(channelData.videoCount)) : 0,
        subscriberGrowthRate: 0, // Would need historical data
        viewGrowthRate: 0, // Would need historical data
        uploadFrequency: 0, // Would need video dates analysis
        engagementScore: 0 // Would need likes/comments data
      },
      metadata: {
        isVerified: (channelData as any).verified || false,
        country: (channelData as any).country,
        joinedDate: (channelData as any).joinedDate,
        lastUpdated: new Date().toISOString()
      }
    }

    // Add comparison data if requested
    if (includeComparison) {
      const allChannels = await db.favoriteChannel.findMany()
      const avgSubscribers = allChannels.reduce((sum, ch) => sum + (Number(ch.subscriberCount) || 0), 0) / allChannels.length
      const avgVideos = allChannels.reduce((sum, ch) => sum + (Number((ch as any).videoCount) || 0), 0) / allChannels.length
      
      stats.comparison = {
        subscriberRank: allChannels.filter(ch => Number(ch.subscriberCount || 0) > Number(channelData.subscriberCount || 0)).length + 1,
        totalChannelsCompared: allChannels.length,
        subscriberPercentile: Math.round((1 - (stats.stats.subscribers - avgSubscribers) / Math.max(avgSubscribers, 1)) * 100),
        videoPercentile: Math.round((1 - (stats.stats.totalVideos - avgVideos) / Math.max(avgVideos, 1)) * 100),
        aboveAverageSubscribers: stats.stats.subscribers > avgSubscribers,
        aboveAverageVideos: stats.stats.totalVideos > avgVideos
      }
    }

    return NextResponse.json(stats)
  } catch (error) {
    // Console statement removed
    return NextResponse.json({ error: 'Failed to fetch channel statistics' }, { status: 500 })
  }
}

async function getAllChannelsStats(includeComparison: boolean, timeframe: string) {
  try {
    // Get all favorite channels
    const favoriteChannels = await db.favoriteChannel.findMany({
      orderBy: { addedAt: 'desc' }
    })

    if (favoriteChannels.length === 0) {
      return NextResponse.json({
        summary: {
          totalChannels: 0,
          totalSubscribers: 0,
          totalVideos: 0,
          totalViews: 0,
          avgSubscribers: 0,
          avgVideos: 0,
          avgViews: 0
        },
        channels: [],
        metadata: {
          generatedAt: new Date().toISOString(),
          timeframe,
          includeComparison
        }
      })
    }

    // Get detailed data for each channel
    if (!Client) {
      return NextResponse.json({ error: 'YouTube client not initialized' }, { status: 500 })
    }
    const youtube = new Client()
    
    const channelDetails: any[] = []
    let totalSubscribers = 0
    let totalVideos = 0
    let totalViews = 0

    for (const favoriteChannel of favoriteChannels) {
      try {
        const channelData = await youtube.getChannel(favoriteChannel.channelId)
        
        if (channelData) {
          const subscribers = channelData.subscriberCount || 0
          const videos = channelData.videoCount || 0
          const views = (channelData as any).viewCount || 0
          
          totalSubscribers += Number(subscribers)
          totalVideos += Number(videos)
          totalViews += Number(views)

          const channelDetail = {
            id: favoriteChannel.id,
            channelId: favoriteChannel.channelId,
            name: channelData.name,
            thumbnail: (channelData as any).thumbnail?.url || (channelData as any).thumbnail || (channelData as any).thumbnails?.[0]?.url,
            subscriberCount: subscribers,
            videoCount: videos,
            viewCount: views,
            addedAt: favoriteChannel.addedAt,
            isVerified: (channelData as any).verified || false,
            stats: {
              avgViewsPerVideo: videos ? Math.round(Number(views) / Number(videos)) : 0,
              daysInFavorites: Math.floor((Date.now() - new Date(favoriteChannel.addedAt).getTime()) / (1000 * 60 * 60 * 24))
            }
          }

          channelDetails.push(channelDetail)
        }
      } catch (error) {
        // Console statement removed
        // Add basic data even if detailed fetch fails
        channelDetails.push({
          id: favoriteChannel.id,
          channelId: favoriteChannel.channelId,
          name: favoriteChannel.name,
          thumbnail: favoriteChannel.thumbnail,
          subscriberCount: favoriteChannel.subscriberCount || 0,
          videoCount: 0,
          viewCount: 0,
          addedAt: favoriteChannel.addedAt,
          isVerified: false,
          stats: {
            avgViewsPerVideo: 0,
            daysInFavorites: Math.floor((Date.now() - new Date(favoriteChannel.addedAt).getTime()) / (1000 * 60 * 60 * 24))
          },
          error: 'Failed to fetch detailed data'
        })
      }
    }

    // Sort by subscriber count
    channelDetails.sort((a, b) => b.subscriberCount - a.subscriberCount)

    // Calculate summary statistics
    const avgSubscribers = favoriteChannels.length > 0 ? Math.round(totalSubscribers / favoriteChannels.length) : 0
    const avgVideos = favoriteChannels.length > 0 ? Math.round(totalVideos / favoriteChannels.length) : 0
    const avgViews = favoriteChannels.length > 0 ? Math.round(totalViews / favoriteChannels.length) : 0

    const summary = {
      totalChannels: favoriteChannels.length,
      totalSubscribers,
      totalVideos,
      totalViews,
      avgSubscribers,
      avgVideos,
      avgViews,
      topChannel: channelDetails[0] || null,
      newestChannel: favoriteChannels.sort((a, b) => new Date(b.addedAt).getTime() - new Date(a.addedAt).getTime())[0],
      oldestChannel: favoriteChannels.sort((a, b) => new Date(a.addedAt).getTime() - new Date(b.addedAt).getTime())[0]
    }

    // Add distribution data
    const distribution = {
      subscriberRanges: {
        under1k: channelDetails.filter(ch => ch.subscriberCount < 1000).length,
        k1to10k: channelDetails.filter(ch => ch.subscriberCount >= 1000 && ch.subscriberCount < 10000).length,
        k10to100k: channelDetails.filter(ch => ch.subscriberCount >= 10000 && ch.subscriberCount < 100000).length,
        k100to1m: channelDetails.filter(ch => ch.subscriberCount >= 100000 && ch.subscriberCount < 1000000).length,
        over1m: channelDetails.filter(ch => ch.subscriberCount >= 1000000).length
      },
      verifiedChannels: channelDetails.filter(ch => ch.isVerified).length,
      totalActiveChannels: channelDetails.filter(ch => !ch.error).length
    }

    return NextResponse.json({
      summary,
      distribution,
      channels: channelDetails,
      metadata: {
        generatedAt: new Date().toISOString(),
        timeframe,
        includeComparison,
        totalProcessed: favoriteChannels.length,
        successfulFetches: channelDetails.filter(ch => !ch.error).length
      }
    })
  } catch (error) {
    // Console statement removed
    return NextResponse.json({ error: 'Failed to fetch channel statistics' }, { status: 500 })
  }
}