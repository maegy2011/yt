'use client'

import { useState, useRef, useEffect, useCallback } from 'react'
import YouTube from 'react-youtube'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Play, Pause, RotateCcw, Plus, Trash2, Save, Bookmark, Edit, Clock, MessageSquare, User, Eye, Heart, ChevronLeft, ChevronRight } from 'lucide-react'

// Import YouTube utility functions (we'll need to create these)
const formatViewCount = (count: number | string | undefined | null): string => {
  if (count === undefined || count === null) return '0 views'
  
  const numCount = typeof count === 'string' ? parseInt(count) : count
  
  if (isNaN(numCount) || numCount < 0) return '0 views'
  
  if (numCount >= 1000000) {
    return `${(numCount / 1000000).toFixed(1)}M views`
  } else if (numCount >= 1000) {
    return `${(numCount / 1000).toFixed(1)}K views`
  } else {
    return `${numCount} views`
  }
}

const formatPublishedAt = (dateString: string): string => {
  const date = new Date(dateString)
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))
  
  if (diffDays === 0) {
    return 'Today'
  } else if (diffDays === 1) {
    return 'Yesterday'
  } else if (diffDays < 30) {
    return `${diffDays} days ago`
  } else if (diffDays < 365) {
    return `${Math.floor(diffDays / 30)} months ago`
  } else {
    return `${Math.floor(diffDays / 365)} years ago`
  }
}

const getChannelName = (video: any): string => {
  return video.channelName || video.channel?.name || 'Unknown Channel'
}

interface VideoNote {
  id: string
  title: string
  comment: string
  startTime: number
  endTime: number
  videoId: string
  videoTitle: string
  channelName?: string
  viewCount?: number
  publishedAt?: string
  thumbnail?: string
}

interface VideoNoteProps {
  videoId: string
  videoTitle: string
  channelName?: string
  viewCount?: number
  publishedAt?: string
  thumbnail?: string
  onFavoriteToggle?: (isFavorited: boolean) => void
  onPreviousVideo?: () => void
  onNextVideo?: () => void
}

export function VideoNote({ 
  videoId, 
  videoTitle, 
  channelName, 
  viewCount, 
  publishedAt, 
  thumbnail,
  onPreviousVideo,
  onNextVideo 
}: VideoNoteProps) {
  const [notes, setNotes] = useState<VideoNote[]>([])
  const [newNote, setNewNote] = useState({ title: '', comment: '', startTime: 0, endTime: 30 })
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const [duration, setDuration] = useState(0)
  const [autoStopTriggered, setAutoStopTriggered] = useState(false)
  const [activeNoteId, setActiveNoteId] = useState<string | null>(null)
  const [isCapturing, setIsCapturing] = useState(false)
  const [editingNoteId, setEditingNoteId] = useState<string | null>(null)
  const [isFavorited, setIsFavorited] = useState(false)
  const playerRef = useRef<any>(null)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)

  // Local notification system
  const [notification, setNotification] = useState<{
    message: string
    type: 'success' | 'error' | 'info'
  } | null>(null)

  const showNotification = useCallback((message: string, type: 'success' | 'error' | 'info' = 'info') => {
    setNotification({ message, type })
    setTimeout(() => setNotification(null), 3000)
  }, [])

  // Placeholder navigation functions
  const handlePreviousVideo = useCallback(() => {
    if (onPreviousVideo) {
      onPreviousVideo()
    } else {
      showNotification('Navigation', 'Previous video feature not available', 'info')
    }
  }, [onPreviousVideo, showNotification])

  const handleNextVideo = useCallback(() => {
    if (onNextVideo) {
      onNextVideo()
    } else {
      showNotification('Navigation', 'Next video feature not available', 'info')
    }
  }, [onNextVideo, showNotification])

  // Load notes from localStorage
  useEffect(() => {
    const savedNotes = localStorage.getItem(`video-notes-${videoId}`)
    if (savedNotes) {
      setNotes(JSON.parse(savedNotes))
    }
  }, [videoId])

  // Save notes to localStorage
  useEffect(() => {
    if (notes.length > 0) {
      localStorage.setItem(`video-notes-${videoId}`, JSON.stringify(notes))
    }
  }, [notes, videoId])

  // Monitor video progress for current time updates
  useEffect(() => {
    const interval = setInterval(() => {
      if (playerRef.current && playerRef.current.getCurrentTime) {
        try {
          const currentTime = playerRef.current.getCurrentTime()
          setCurrentTime(currentTime)
        } catch (error) {
          console.error('Error getting current time:', error)
        }
      }
    }, 100) // Update every 100ms for more accuracy

    return () => clearInterval(interval)
  }, []) // Run once on mount

  // Monitor video progress and enforce timestamp limits
  useEffect(() => {
    if (isPlaying && playerRef.current && activeNoteId) {
      const activeNote = notes.find(note => note.id === activeNoteId)
      if (!activeNote) return

      intervalRef.current = setInterval(() => {
        if (playerRef.current && playerRef.current.getCurrentTime) {
          try {
            const currentTime = playerRef.current.getCurrentTime()
            const playerState = playerRef.current.getPlayerState()
            
            setCurrentTime(currentTime)
            
            // Only check end time if video is actually playing (state === 1)
            if (playerState === 1 && currentTime >= activeNote.endTime) {
              console.log('Auto-stopping at end time:', currentTime, '>=', activeNote.endTime)
              setAutoStopTriggered(true)
              playerRef.current.pauseVideo()
              setIsPlaying(false)
              
              // Reset to start time after a brief delay
              setTimeout(() => {
                if (playerRef.current) {
                  playerRef.current.seekTo(activeNote.startTime, true)
                  setCurrentTime(activeNote.startTime)
                  setAutoStopTriggered(false)
                }
              }, 500)
            }
          } catch (error) {
            console.error('Error monitoring video progress:', error)
          }
        }
      }, 200) // Check every 200ms for better responsiveness
    } else {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
        intervalRef.current = null
      }
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
      }
    }
  }, [isPlaying, activeNoteId, notes])

  const toggleFavorite = async () => {
    setIsFavorited(!isFavorited)
    // Here you would typically make an API call to save the favorite state
    // For now, just toggle the local state
    showNotification(isFavorited ? 'Added to favorites' : 'Removed from favorites', 'info')
  }

  const handleAddNote = () => {
    if (newNote.title.trim() && newNote.startTime < newNote.endTime) {
      const note: VideoNote = {
        id: Date.now().toString(),
        title: newNote.title,
        comment: newNote.comment,
        startTime: newNote.startTime,
        endTime: newNote.endTime,
        videoId,
        videoTitle,
        channelName: channelName || '',
        viewCount: viewCount || 0,
        publishedAt: publishedAt || '',
        thumbnail: thumbnail || ''
      }
      setNotes([...notes, note])
      setNewNote({ title: '', comment: '', startTime: 0, endTime: 30 })
    }
  }

  const handleCaptureStart = () => {
    // Get the most accurate current time directly from the player
    let accurateCurrentTime = currentTime
    
    if (playerRef.current && playerRef.current.getCurrentTime) {
      try {
        accurateCurrentTime = playerRef.current.getCurrentTime()
        console.log('Captured start time from player:', accurateCurrentTime)
      } catch (error) {
        console.error('Error getting current time from player:', error)
        // Fallback to state value
        accurateCurrentTime = currentTime
      }
    }
    
    const startTime = Math.floor(accurateCurrentTime)
    setNewNote({ 
      ...newNote, 
      startTime: startTime,
      endTime: Math.max(startTime + 1, newNote.endTime)
    })
    setIsCapturing(true)
    console.log('Start time set to:', startTime, 'from current time:', accurateCurrentTime)
  }

  const handleSaveNote = () => {
    // Get the most accurate current time directly from the player
    let accurateCurrentTime = currentTime
    
    if (playerRef.current && playerRef.current.getCurrentTime) {
      try {
        accurateCurrentTime = playerRef.current.getCurrentTime()
        console.log('Captured end time from player:', accurateCurrentTime)
      } catch (error) {
        console.error('Error getting current time from player:', error)
        // Fallback to state value
        accurateCurrentTime = currentTime
      }
    }
    
    const endTime = Math.floor(accurateCurrentTime)
    if (endTime > newNote.startTime) {
      const note: VideoNote = {
        id: Date.now().toString(),
        title: newNote.title || `Clip from ${formatTime(newNote.startTime)} to ${formatTime(endTime)}`,
        comment: newNote.comment,
        startTime: newNote.startTime,
        endTime: endTime,
        videoId,
        videoTitle
      }
      setNotes([...notes, note])
      setNewNote({ title: '', comment: '', startTime: 0, endTime: 30 })
      setIsCapturing(false)
      console.log('Note saved with end time:', endTime, 'from current time:', accurateCurrentTime)
    } else {
      console.log('End time not greater than start time:', endTime, '<=', newNote.startTime)
    }
  }

  const handleUpdateNote = (noteId: string, comment: string) => {
    setNotes(notes.map(note => 
      note.id === noteId ? { ...note, comment } : note
    ))
    setEditingNoteId(null)
  }

  const handleDeleteNote = (id: string) => {
    // Direct deletion without confirmation
    setNotes(notes.filter(note => note.id !== id))
    if (activeNoteId === id) {
      setActiveNoteId(null)
    }
    showNotification('Note Deleted', 'The note has been removed successfully', 'success')
  }

  const handlePlayNote = (note: VideoNote) => {
    if (playerRef.current) {
      playerRef.current.seekTo(note.startTime, true)
      playerRef.current.playVideo()
      setIsPlaying(true)
      setActiveNoteId(note.id)
    }
  }

  const handlePlay = () => {
    if (playerRef.current) {
      playerRef.current.playVideo()
      setIsPlaying(true)
    }
  }

  const handlePause = () => {
    if (playerRef.current) {
      playerRef.current.pauseVideo()
      setIsPlaying(false)
    }
  }

  const handleReset = () => {
    const activeNote = notes.find(note => note.id === activeNoteId)
    if (playerRef.current && activeNote) {
      playerRef.current.seekTo(activeNote.startTime, true)
      setCurrentTime(activeNote.startTime)
    }
  }

  const onReady = (event: any) => {
    playerRef.current = event.target
    setDuration(event.target.getDuration())
  }

  const onStateChange = (event: any) => {
    const state = event.data
    if (state === 1) { // Playing
      setIsPlaying(true)
    } else if (state === 2) { // Paused
      setIsPlaying(false)
    } else if (state === 0) { // Ended
      setIsPlaying(false)
    }
  }

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }

  const opts = {
    height: '390',
    width: '100%',
    playerVars: {
      autoplay: 0,
      controls: 1,
      rel: 0,
      showinfo: 0,
      modestbranding: 1,
    },
  }

  return (
    <div className="space-y-4 sm:space-y-6">
      {/* Notification */}
      {notification && (
        <div className={`fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 ${
          notification.type === 'success' ? 'bg-green-500 text-white' :
          notification.type === 'error' ? 'bg-red-500 text-white' :
          'bg-blue-500 text-white'
        }`}>
          {notification.message}
        </div>
      )}
      
      {/* Video Player */}
      <div className="relative aspect-video bg-black rounded-lg overflow-hidden">
        <YouTube
          videoId={videoId}
          opts={{
            ...opts,
            width: '100%',
            height: '100%'
          }}
          onReady={onReady}
          onStateChange={onStateChange}
          className="w-full h-full"
        />
      </div>

      {/* Video Info Section */}
      <Card>
        <CardContent className="p-4 sm:p-6">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
            <div>
              <h2 className="text-xl sm:text-2xl font-bold mb-1">
                {videoTitle}
              </h2>
              <p className="text-muted-foreground">{channelName || 'Unknown Channel'}</p>
            </div>
            <div className="flex items-center gap-4 text-sm text-muted-foreground">
              {viewCount && (
                <span>{formatViewCount(viewCount)}</span>
              )}
              {publishedAt && (
                <span>{formatPublishedAt(publishedAt)}</span>
              )}
            </div>
          </div>
          
          {/* Control Buttons */}
          <div className="flex gap-3 mt-4">
            <Button
              onClick={toggleFavorite}
              className={`transition-all duration-200 hover:scale-105 ${
                isFavorited
                  ? 'bg-red-600 hover:bg-red-700 text-white'
                  : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
              }`}
            >
              <Heart className={`w-4 h-4 ${isFavorited ? 'fill-current' : ''}`} />
            </Button>
            <div className="relative">
              <Button
                onClick={handleCaptureStart}
                variant="outline"
                className="transition-all duration-200 hover:scale-105"
                title="Set start time for quick capture"
              >
                <Bookmark className="w-4 h-4 mr-2" />
                Set Start
                <span className="text-xs opacity-75">{formatTime(currentTime)}</span>
              </Button>
              <div className="absolute -right-2 top-1/2 top-1/2 flex items-center">
                <Button
                  onClick={handlePreviousVideo}
                  variant="outline"
                  title="Move to previous video"
                  className="transition-all duration-200 hover:scale-105 text-xs px-2 py-1"
                >
                  <ChevronLeft className="w-3 h-3" />
                </Button>
                <Button
                  onClick={handleNextVideo}
                  variant="outline"
                  title="Move to next video"
                  className="transition-all duration-200 hover:scale-105 text-xs px-2 py-1"
                >
                  <ChevronRight className="w-3 h-3" />
                </Button>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Note Creation */}
      <Card>
        <CardContent className="p-4 sm:p-6">
          <div className="flex items-center gap-3 mb-4">
            <div className="p-2 bg-green-100 dark:bg-green-900/30 rounded-lg">
              <MessageSquare className="w-5 h-5 text-green-600 dark:text-green-400" />
            </div>
            <h2 className="text-lg font-semibold">
              Create Note
            </h2>
          </div>

          <div className="space-y-4">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="note-title">Title</Label>
                <Input
                  id="note-title"
                  value={newNote.title}
                  onChange={(e) => setNewNote({ ...newNote, title: e.target.value })}
                  placeholder="Enter a title for this clip..."
                />
              </div>
              
              <div>
                <Label htmlFor="note-comment">Comment</Label>
                <Input
                  id="note-comment"
                  value={newNote.comment}
                  onChange={(e) => setNewNote({ ...newNote, comment: e.target.value })}
                  placeholder="Add your notes or comments..."
                />
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="start-time">Start Time (seconds)</Label>
                <Input
                  id="start-time"
                  type="number"
                  value={newNote.startTime}
                  onChange={(e) => {
                    const value = Number(e.target.value)
                    setNewNote({ ...newNote, startTime: value, endTime: Math.max(value + 1, newNote.endTime) })
                  }}
                  min="0"
                />
              </div>
              
              <div>
                <Label htmlFor="end-time">End Time (seconds)</Label>
                <Input
                  id="end-time"
                  type="number"
                  value={newNote.endTime}
                  onChange={(e) => {
                    const value = Number(e.target.value)
                    setNewNote({ ...newNote, endTime: value, startTime: Math.min(newNote.startTime, value - 1) })
                  }}
                  min="0"
                />
              </div>
            </div>

            <div className="flex items-center h-10 px-3 bg-muted rounded-lg">
              <Clock className="w-4 h-4 text-muted-foreground mr-2" />
              <span className="text-sm font-medium">
                Duration: {formatTime(newNote.endTime - newNote.startTime)}
              </span>
            </div>

            {!isCapturing && (
              <Button
                onClick={handleAddNote}
                disabled={!newNote.title.trim() || newNote.startTime >= newNote.endTime}
                className="w-full"
              >
                <Plus className="w-4 h-4 mr-2" />
                Create Note
              </Button>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Video Notes List */}
      {notes.length > 0 && (
        <Card>
          <CardContent className="p-4 sm:p-6">
            <div className="flex items-center gap-3 mb-4">
              <div className="p-2 bg-amber-100 dark:bg-amber-900/30 rounded-lg">
                <MessageSquare className="w-5 h-5 text-amber-600 dark:text-amber-400" />
              </div>
              <div>
                <h2 className="text-lg font-semibold">
                  Video Notes ({notes.length})
                </h2>
              </div>
            </div>

            <div className="space-y-3 max-h-96 overflow-y-auto">
              {notes.map((note) => (
                <div
                  key={note.id}
                  className={`p-4 rounded-lg border transition-all duration-200 ${
                    activeNoteId === note.id
                      ? 'border-primary bg-primary/5'
                      : 'border-border bg-card hover:bg-muted/50'
                  }`}
                >
                  <div className="flex items-start gap-3">
                    <div className={`p-2 rounded-lg ${
                      activeNoteId === note.id
                        ? 'bg-primary/20'
                        : 'bg-muted'
                    }`}>
                      <Play className="w-4 h-4" />
                    </div>
                    
                    <div className="flex-1 min-w-0">
                      <h3 className="font-semibold truncate mb-1">
                        {note.title}
                      </h3>
                      
                      <div className="flex items-center gap-4 text-sm text-muted-foreground mb-2">
                        <span className="flex items-center gap-1">
                          <Clock className="w-3 h-3" />
                          {formatTime(note.startTime)} - {formatTime(note.endTime)}
                        </span>
                        <span>
                          Duration: {formatTime(note.endTime - note.startTime)}
                        </span>
                      </div>
                      
                      {/* Comment Display/Edit */}
                      {editingNoteId === note.id ? (
                        <Input
                          defaultValue={note.comment}
                          placeholder="Add your comment..."
                          className="text-sm mb-3"
                          onKeyPress={(e) => {
                            if (e.key === 'Enter') {
                              handleUpdateNote(note.id, (e.target as HTMLInputElement).value)
                            }
                          }}
                          onBlur={(e) => handleUpdateNote(note.id, e.target.value)}
                          autoFocus
                        />
                      ) : (
                        <div className="mb-3">
                          {note.comment ? (
                            <p className="text-sm text-muted-foreground italic bg-muted p-2 rounded">
                              {note.comment}
                            </p>
                          ) : (
                            <button
                              onClick={() => setEditingNoteId(note.id)}
                              className="text-sm text-primary hover:underline"
                            >
                              + Add comment
                            </button>
                          )}
                        </div>
                      )}
                      
                      <div className="flex items-center gap-2">
                        <Button
                          onClick={() => handlePlayNote(note)}
                          size="sm"
                        >
                          <Play className="w-3 h-3 mr-1" />
                          Play
                        </Button>
                        
                        {note.comment && editingNoteId !== note.id && (
                          <Button
                            onClick={() => setEditingNoteId(note.id)}
                            size="sm"
                            variant="outline"
                          >
                            <Edit className="w-3 h-3" />
                          </Button>
                        )}
                        
                        <Button
                          onClick={() => handleDeleteNote(note.id)}
                          size="sm"
                          variant="outline"
                          className="text-destructive hover:text-destructive"
                        >
                          <Trash2 className="w-3 h-3" />
                        </Button>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}