/**
 * Advanced Logging Infrastructure
 * Provides structured logging with multiple levels, outputs, and monitoring integration
 */

import { monitoring } from './monitoring';

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  FATAL = 4
}

export interface LogContext {
  requestId?: string;
  userId?: string;
  sessionId?: string;
  ip?: string;
  userAgent?: string;
  method?: string;
  url?: string;
  statusCode?: number;
  duration?: number;
  [key: string]: any;
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  levelName: string;
  message: string;
  context?: LogContext;
  error?: {
    name: string;
    message: string;
    stack?: string;
    code?: string;
  };
  metadata?: Record<string, any>;
  service: string;
  environment: string;
  version: string;
}

export interface LoggerConfig {
  level: LogLevel;
  service: string;
  enableConsole: boolean;
  enableFile: boolean;
  enableRemote: boolean;
  remoteEndpoint?: string;
  fileMaxSize?: number;
  fileMaxFiles?: number;
  structuredOutput: boolean;
  includeStackTrace: boolean;
  sanitizeData: boolean;
}

class Logger {
  private config: LoggerConfig;
  private logBuffer: LogEntry[] = [];
  private bufferSize = 1000;
  private flushInterval = 5000; // 5 seconds
  private flushTimer?: NodeJS.Timeout;

  constructor(config: Partial<LoggerConfig> = {}) {
    this.config = {
      level: LogLevel.INFO,
      service: 'youtube-clone',
      enableConsole: true,
      enableFile: false,
      enableRemote: false,
      structuredOutput: true,
      includeStackTrace: true,
      sanitizeData: true,
      ...config
    };

    // Start flush timer for buffered logs
    this.startFlushTimer();
  }

  /**
   * Log a debug message
   */
  debug(message: string, context?: LogContext): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  /**
   * Log an info message
   */
  info(message: string, context?: LogContext): void {
    this.log(LogLevel.INFO, message, context);
  }

  /**
   * Log a warning message
   */
  warn(message: string, context?: LogContext): void {
    this.log(LogLevel.WARN, message, context);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: Error | Record<string, any>, context?: LogContext): void {
    this.log(LogLevel.ERROR, message, context, error);
  }

  /**
   * Log a fatal error message
   */
  fatal(message: string, error?: Error | Record<string, any>, context?: LogContext): void {
    this.log(LogLevel.FATAL, message, context, error);
  }

  /**
   * Log HTTP request
   */
  logRequest(context: LogContext): void {
    const message = `${context.method} ${context.url} - ${context.statusCode}`;
    const level = context.statusCode && context.statusCode >= 400 ? LogLevel.WARN : LogLevel.INFO;
    
    this.log(level, message, {
      ...context,
      type: 'http_request'
    });
  }

  /**
   * Log API response
   */
  logResponse(context: LogContext): void {
    const message = `${context.method} ${context.url} - ${context.statusCode} (${context.duration}ms)`;
    const level = context.statusCode && context.statusCode >= 400 ? LogLevel.WARN : LogLevel.INFO;
    
    this.log(level, message, {
      ...context,
      type: 'http_response'
    });
  }

  /**
   * Log database query
   */
  logQuery(query: string, duration: number, context?: LogContext): void {
    const level = duration > 5000 ? LogLevel.WARN : LogLevel.DEBUG;
    const message = `DB Query: ${query.substring(0, 100)}... (${duration}ms)`;
    
    this.log(level, message, {
      ...context,
      type: 'database_query',
      query: query.substring(0, 500), // Limit query length
      duration
    });
  }

  /**
   * Log user action
   */
  logUserAction(action: string, context?: LogContext): void {
    this.info(`User action: ${action}`, {
      ...context,
      type: 'user_action',
      action
    });
  }

  /**
   * Log security event
   */
  logSecurity(event: string, severity: 'low' | 'medium' | 'high' | 'critical', context?: LogContext): void {
    const level = severity === 'critical' ? LogLevel.FATAL : 
                  severity === 'high' ? LogLevel.ERROR :
                  severity === 'medium' ? LogLevel.WARN : LogLevel.INFO;
    
    this.log(level, `Security: ${event}`, {
      ...context,
      type: 'security_event',
      securityEvent: event,
      severity
    });
  }

  /**
   * Log performance metric
   */
  logPerformance(operation: string, duration: number, context?: LogContext): void {
    const level = duration > 10000 ? LogLevel.WARN : LogLevel.DEBUG;
    this.log(level, `Performance: ${operation} (${duration}ms)`, {
      ...context,
      type: 'performance_metric',
      operation,
      duration
    });

    // Also log to monitoring system
    monitoring.logPerformance(operation, duration, context);
  }

  /**
   * Core logging method
   */
  private log(level: LogLevel, message: string, context?: LogContext, error?: Error | Record<string, any>): void {
    // Skip if level is below configured threshold
    if (level < this.config.level) {
      return;
    }

    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      levelName: LogLevel[level],
      message: this.config.sanitizeData ? this.sanitizeMessage(message) : message,
      context: this.config.sanitizeData ? this.sanitizeContext(context) : context,
      service: this.config.service,
      environment: process.env.NODE_ENV || 'development',
      version: process.env.npm_package_version || '1.0.0'
    };

    // Add error information if provided
    if (error) {
      if (error instanceof Error) {
        logEntry.error = {
          name: error.name,
          message: error.message,
          stack: this.config.includeStackTrace ? error.stack : undefined
        };
      } else {
        logEntry.error = {
          name: 'UnknownError',
          message: JSON.stringify(error)
        };
      }
    }

    // Add to buffer
    this.logBuffer.push(logEntry);

    // Flush buffer if it's getting full
    if (this.logBuffer.length >= this.bufferSize) {
      this.flush();
    }

    // Immediate output for critical logs
    if (level >= LogLevel.ERROR) {
      this.writeToOutputs([logEntry]);
    }
  }

  /**
   * Flush log buffer to outputs
   */
  private flush(): void {
    if (this.logBuffer.length === 0) {
      return;
    }

    const logs = [...this.logBuffer];
    this.logBuffer = [];

    this.writeToOutputs(logs);
  }

  /**
   * Write logs to configured outputs
   */
  private writeToOutputs(logs: LogEntry[]): void {
    if (this.config.enableConsole) {
      this.writeToConsole(logs);
    }

    if (this.config.enableFile) {
      this.writeToFile(logs);
    }

    if (this.config.enableRemote && this.config.remoteEndpoint) {
      this.writeToRemote(logs);
    }
  }

  /**
   * Write logs to console
   */
  private writeToConsole(logs: LogEntry[]): void {
    logs.forEach(log => {
      const colorCode = this.getColorCode(log.level);
      const resetCode = '\x1b[0m';
      
      if (this.config.structuredOutput) {
        const structuredLog = {
          timestamp: log.timestamp,
          level: log.levelName,
          service: log.service,
          message: log.message,
          context: log.context,
          error: log.error
        };
        
        console.log(
          `${colorCode}[${log.timestamp}] ${log.levelName.toUpperCase()} ${log.service}${resetCode}`,
          structuredLog
        );
      } else {
        console.log(
          `${colorCode}[${log.timestamp}] ${log.levelName.toUpperCase()} ${log.service}: ${log.message}${resetCode}`
        );
        
        if (log.context) {
          // Console statement removed;
        }
        
        if (log.error) {
          // Console statement removed;
        }
      }
    });
  }

  /**
   * Write logs to file (placeholder)
   */
  private writeToFile(logs: LogEntry[]): void {
    // In a real implementation, this would write to a file
    // For now, we'll just log to monitoring
    logs.forEach(log => {
      monitoring.debug('Log written to file', { logId: `${log.timestamp}-${log.level}` });
    });
  }

  /**
   * Write logs to remote endpoint (placeholder)
   */
  private writeToRemote(logs: LogEntry[]): void {
    // In a real implementation, this would send logs to a remote service
    // For now, we'll just log to monitoring
    monitoring.debug('Logs sent to remote endpoint', { 
      logCount: logs.length,
      endpoint: this.config.remoteEndpoint 
    });
  }

  /**
   * Get ANSI color code for log level
   */
  private getColorCode(level: LogLevel): string {
    switch (level) {
      case LogLevel.DEBUG: return '\x1b[36m'; // Cyan
      case LogLevel.INFO: return '\x1b[32m';  // Green
      case LogLevel.WARN: return '\x1b[33m';  // Yellow
      case LogLevel.ERROR: return '\x1b[31m'; // Red
      case LogLevel.FATAL: return '\x1b[35m'; // Magenta
      default: return '\x1b[37m'; // White
    }
  }

  /**
   * Sanitize message to remove sensitive information
   */
  private sanitizeMessage(message: string): string {
    return message
      .replace(/password["\s]*[:=]["\s]*[^"\\s}]+/gi, 'password=***')
      .replace(/token["\s]*[:=]["\s]*[^"\\s}]+/gi, 'token=***')
      .replace(/api[_-]?key["\s]*[:=]["\s]*[^"\\s}]+/gi, 'api_key=***')
      .replace(/secret["\s]*[:=]["\s]*[^"\\s}]+/gi, 'secret=***');
  }

  /**
   * Sanitize context to remove sensitive information
   */
  private sanitizeContext(context?: LogContext): LogContext | undefined {
    if (!context) return context;

    const sensitiveKeys = ['password', 'token', 'secret', 'api_key', 'authorization'];
    const sanitized = { ...context };

    sensitiveKeys.forEach(key => {
      if (key in sanitized) {
        (sanitized as any)[key] = '***';
      }
    });

    return sanitized;
  }

  /**
   * Start automatic flush timer
   */
  private startFlushTimer(): void {
    this.flushTimer = setInterval(() => {
      this.flush();
    }, this.flushInterval);
  }

  /**
   * Stop automatic flush timer
   */
  stop(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
      this.flushTimer = undefined;
    }
    this.flush();
  }

  /**
   * Update logger configuration
   */
  updateConfig(newConfig: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }

  /**
   * Get current configuration
   */
  getConfig(): LoggerConfig {
    return { ...this.config };
  }

  /**
   * Get recent logs from buffer
   */
  getRecentLogs(count = 100): LogEntry[] {
    return this.logBuffer.slice(-count);
  }

  /**
   * Clear log buffer
   */
  clearBuffer(): void {
    this.logBuffer = [];
  }
}

// Default logger instance
export const logger = new Logger();

// Create specialized loggers for different services
export const apiLogger = new Logger({ service: 'api' });
export const dbLogger = new Logger({ service: 'database' });
export const authLogger = new Logger({ service: 'auth' });
export const youtubeLogger = new Logger({ service: 'youtube' });

// Request context helper
export function createRequestContext(request: Request, additional?: LogContext): LogContext {
  const url = new URL(request.url);
  
  return {
    method: request.method,
    url: url.pathname + url.search,
    userAgent: request.headers.get('user-agent') || undefined,
    ip: request.headers.get('x-forwarded-for') || 
        request.headers.get('x-real-ip') || 
        'unknown',
    ...additional
  };
}

// Performance logging helper
export function logAsyncOperation<T>(
  operation: string,
  fn: () => Promise<T>,
  context?: LogContext
): Promise<T> {
  const startTime = Date.now();
  
  return fn().then(
    result => {
      const duration = Date.now() - startTime;
      logger.logPerformance(operation, duration, context);
      return result;
    },
    error => {
      const duration = Date.now() - startTime;
      logger.error(`Operation failed: ${operation}`, error, {
        ...context,
        duration,
        operation
      });
      throw error;
    }
  );
}

// Middleware helper for Next.js API routes
export function withLogging(handler: (request: Request, ...args: any[]) => Promise<any>) {
  return async (request: Request, ...args: any[]) => {
    const startTime = Date.now();
    const context = createRequestContext(request);
    
    try {
      logger.logRequest(context);
      
      const result = await handler(request, ...args);
      
      const duration = Date.now() - startTime;
      logger.logResponse({
        ...context,
        statusCode: result?.status || 200,
        duration
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error('Request failed', error instanceof Error ? error : new Error(String(error)), {
        ...context,
        duration
      });
      
      throw error;
    }
  };
}

export default logger;